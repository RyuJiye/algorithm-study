# 분할정복 알고리즘

# 분할정복 알고리즘

분할정복 알고리즘은 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이다. 대표적인 예로는 정렬 알고리즘 중에서 퀵 정렬이나 합병 정렬과 이진 탐색, 선택 문제, 고속 푸리에 변환 문제들이 대표적이다. 

문제를 (**비슷한 크기**의) 둘 이상의 부분 문제로 **나눈 뒤 (Divide)**

각 문제에 대한 답을 **계산하고 (Conquer)**

원래 문제에 대한 답으로 **병합 (Merge)**

## 정렬 알고리즘 비교

| 정렬 알고리즘 | 최대 실행 시간 | 최소 실행 시간 | 평균 실행 시간 |
| --- | --- | --- | --- |
| 선택 정렬 | O(n^2) | O(n^2) | O(n^2) |
| 삽입 정렬 | O(n^2) | O(n) | O(n^2) |
| 합병 정렬 | O(nlgn) | O(nlgn) | O(nlgn) |
| 퀵 정렬 | O(n^2) | O(nlgn) | O(nlgn) |

## 분할정복 특징 및 장단점

### 분할정복 장점

1. 병렬 처리가 가능
    
    분할된 작은 부분 문제들은 독립적으로 처리될 수 있으므로, 병렬 처리에 적합하다.
    
2. 재귀적 구현 가능
    
    분할정복은 작은 부분 문제들을 독립적으로 해결하고, 결합하는 과정에서 재귀적으로 구현할 수 있다.
    
3. 문제를 단순화
    
    큰 문제를 작은 부분 문제로 분할하므로, 문제를 단순화시킬 수 있다.
    

### 분할정복 단점

1. 문제 분할에 대한 비용
    
    문제를 작은 부분 문제로 분할하기 위해 비용이 들어갈 수 있다.
    
2. 메모리 사용량 증가
    
    분할된 작은 부분 문제들을 각각 저장해야 하므로, 메모리 사용량이 증가할 수 있다.
    

## 합병 정렬

하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.

### **동작 과정**

**1) Divide**

입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.

**2) Conquer**

부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면(left<right) 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

**3) Combine**

정렬된 부분 배열들을 하나의 배열에 합병한다.

## 퀵 정렬

특정 원소 피봇(pivot)을 기준으로 주어진 배열을 두 부분 배열로 분할하고 각 부분 배열에 대해 퀵 정렬을 순환적으로 적용하는 방식이다.

### **동작 과정**

**1) Divide**

피봇 하나를 선택하여 피봇을 기준으로 2개의 부분 배열로 분할한다.

**2) Conquer**

피봇을 기준으로 피봇보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서 부터 피봇보다 큰 값을 찾고 오른쪽에서 부터는 피봇보다 작은 값을 찾아서 두 원소를 교환한다. 분할된 부분 배열의 크기가 0이나 1일 될때까지 반복한다.

**3) Combine**

conquer과정에서 값의 위치가 바뀌므로 따로 결합은 하지 않는다.

## 이진 탐색

정렬된 데이터를 효과적으로 탐색할 수 있는 방법이다. (정렬된 데이터만 사용 가능; 참고로 정렬되지 않은 데이터 탐색은 파라메트릭 서치로 가능)

### **동작 과정**

**1) Divide**

배열의 가운데 원소를 기준으로 왼쪽, 오른쪽 부분배열로 분할한다. 탐색키와 가운데 원소가 같으면 분할을 종료한다.

**2) Conquer**

탐색키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출하고, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 호출한다.

**3) Combine**

탐색 결과가 직접 반환되므로 결합이 불필요하다.